using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Nino.Shared;

namespace Nino.Serialization
{
    /// <summary>
    /// Nino code generator
    /// </summary>
    public static class CodeGenerator
    {
        /// <summary>
        /// Generate serialization code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="outputPath"></param>
        public static void GenerateSerializationCodeForAllTypePossible(string outputPath = "Nino/Generated")
        {
            //find all types
            var types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToList().FindAll(t =>
            {
                //find NinoSerializeAttribute
                NinoSerializeAttribute[] ns =
                    (NinoSerializeAttribute[])t.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
                if (ns.Length == 0) return false;
                return true;
            }).ToList();
            //iterate
            foreach (var type in types)
            {
                //gen
                GenerateSerializationCode(type, outputPath);
            }
        }

        /// <summary>
        /// Generate serialization code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="type"></param>
        /// <param name="outputPath"></param>
        public static void GenerateSerializationCode(Type type, string outputPath = "Nino/Generated")
        {
            //find NinoSerializeAttribute
            NinoSerializeAttribute[] ns =
                (NinoSerializeAttribute[])type.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
            if (ns.Length == 0) return;

            //code template
            string template =
                @"/* this is generated by nino */
{namespace}
{start}
    public partial struct {type}
    {
        #region NINO_CODEGEN
        private object[] NinoGetMembers()
        {
            return new object[] { {members} };
        }


        private void NinoSetMembers(object[] data)
        {
{fields}
        }
        #endregion
    }
{end}";
            if (type.IsClass)
            {
                template = template.Replace("struct", "class");
            }

            //replace namespace
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                template = template.Replace("{namespace}", $"namespace {type.Namespace}");
                template = template.Replace("{start}", "{");
                template = template.Replace("{end}", "}");
            }

            //class full name
            var classFullName =
                $"{type.GetFriendlyName()}";
            //replace full name
            template = template.Replace("{type}", classFullName);

            //find members
            TypeModel.TryGetModel(type, out var model);
            //invalid model
            if (model != null)
            {
                if (!model.valid)
                {
                    throw new InvalidOperationException("invalid model");
                }
            }

            //generate model
            if (model == null)
            {
                model = TypeModel.CreateModel(type);
            }

            Dictionary<ushort, MemberInfo> members = model.members;

            #region serialize

            //build params
            StringBuilder sb = new StringBuilder();
            var keys = members.Keys.OrderBy(k => k);
            foreach (var key in keys)
            {
                sb.Append(members[key].Name).Append(",");
            }

            //remove comma at the end
            sb.Remove(sb.Length - 1, 1);

            //replace template members
            template = template.Replace("{members}", sb.ToString());

            #endregion

            #region deserialize

            sb.Clear();
            int index = 0;
            keys = members.Keys.OrderBy(k => k);
            foreach (var key in keys)
            {
                var mt = members[key] is FieldInfo fi ? fi.FieldType : ((PropertyInfo)members[key]).PropertyType;
                //int, long, uint, ulong需要考虑压缩
                if (mt == ConstMgr.IntType)
                {
                    sb.Append($"            this.{members[key].Name} = System.Convert.ToInt32(data[{index}]);\n");
                }
                else if (mt == ConstMgr.UIntType)
                {
                    sb.Append($"            this.{members[key].Name} = System.Convert.ToUInt32(data[{index}]);\n");
                }
                else if (mt == ConstMgr.LongType)
                {
                    sb.Append($"            this.{members[key].Name} = System.Convert.ToInt64(data[{index}]);\n");
                }
                else if (mt == ConstMgr.ULongType)
                {
                    sb.Append($"            this.{members[key].Name} = System.Convert.ToUInt64(data[{index}]);\n");
                }
                else
                {
                    sb.Append(
                        $"            this.{members[key].Name} = ({mt.Namespace}{(!string.IsNullOrEmpty(mt.Namespace) ? "." : "")}{mt.GetFriendlyName()})data[{index}];\n");
                }

                index++;
            }

            //remove comma at the end
            sb.Remove(sb.Length - 1, 1);

            //replace template fiedls
            template = template.Replace("{fields}", sb.ToString());

            #endregion

            //save path
            var output = Path.Combine(ConstMgr.AssetPath, outputPath);
            if (!Directory.Exists(output))
            {
                Directory.CreateDirectory(output);
            }

            //save file path
            output = Path.Combine(output,
                $"{type.Namespace}{(!string.IsNullOrEmpty(type.Namespace) ? "." : "")}{type.GetFriendlyName()}"
                    .Replace(".", "_").Replace(",", "_")
                    .Replace("<", "_").Replace(">", "_") +
                "_Serialize.cs");
            if (File.Exists(output))
            {
                File.Delete(output);
            }

            //save
            File.WriteAllText(output, template);

            Logger.D("Code Gen", $"saved {output}");
        }

        /// <summary>
        /// 获取类型名字
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private static string GetFriendlyName(this Type type)
        {
            string friendlyName = type.Name;
            if (type.IsGenericType)
            {
                int iBacktick = friendlyName.IndexOf('`');
                if (iBacktick > 0)
                {
                    friendlyName = friendlyName.Remove(iBacktick);
                }

                friendlyName += "<";
                Type[] typeParameters = type.GetGenericArguments();
                for (int i = 0; i < typeParameters.Length; ++i)
                {
                    string typeParamName =
                        $"{typeParameters[i].Namespace}{(!string.IsNullOrEmpty(typeParameters[i].Namespace) ? "." : "")}{GetFriendlyName(typeParameters[i])}";
                    friendlyName += (i == 0 ? typeParamName : "," + typeParamName);
                }

                friendlyName += ">";
            }

            return friendlyName;
        }
    }
}