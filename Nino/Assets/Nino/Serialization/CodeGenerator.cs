using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Nino.Shared;

namespace Nino.Serialization
{
    /// <summary>
    /// Nino code generator
    /// </summary>
    public static class CodeGenerator
    {
        /// <summary>
        /// Generate serialize code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="outputPath"></param>
        public static void GenerateSerializeCodeForAllTypePossible(string outputPath = "Nino/Generated")
        {
            //find all types
            var types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(a => a.GetTypes()).ToList().FindAll(t =>
            {
                //find NinoSerializeAttribute
                NinoSerializeAttribute[] ns =
                    (NinoSerializeAttribute[])t.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
                if (ns.Length == 0) return false;
                return true;
            }).ToList();
            //iterate
            foreach (var type in types)
            {
                //gen
                GenerateSerializeCode(type, outputPath);
            }
        }

        /// <summary>
        /// Generate serialize code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="type"></param>
        /// <param name="outputPath"></param>
        public static void GenerateSerializeCode(Type type, string outputPath = "Nino/Generated")
        {
            //find NinoSerializeAttribute
            NinoSerializeAttribute[] ns =
                (NinoSerializeAttribute[])type.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
            if (ns.Length == 0) return;

            //code template
            string template =
                @"/* this is generated by nino */
{namespace}
{start}
    public partial struct {type}
    {
        #region NINO_CODEGEN
        private object[] NinoGetMembers()
        {
            return new object[] { {members} };
        }
        #endregion
    }
{end}";
            if (type.IsClass)
            {
                template = template.Replace("struct", "class");
            }

            //replace namespace
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                template = template.Replace("{namespace}", $"namespace {type.Namespace}");
                template = template.Replace("{start}", "{");
                template = template.Replace("{end}", "}");
            }

            //class full name
            var classFullName =
                $"{type.GetFriendlyName()}";
            //replace full name
            template = template.Replace("{type}", classFullName);

            //find members
            //store temp attr
            NinoMemberAttribute sp;
            //flag
            const BindingFlags flags = BindingFlags.Default | BindingFlags.DeclaredOnly | BindingFlags.Public |
                                       BindingFlags.NonPublic | BindingFlags.Instance;
            Dictionary<ushort, string> members = new Dictionary<ushort, string>();
            //fetch fields (only public and private fields that declared in the type)
            FieldInfo[] fs = type.GetFields(flags);
            //iterate fields
            foreach (var f in fs)
            {
                sp = f.GetCustomAttribute(typeof(NinoMemberAttribute), false) as NinoMemberAttribute;
                //not fetch all and no attribute => skip this member
                if (sp == null) continue;
                //record field
                members.Add(sp.Index, f.Name);
            }

            //fetch properties (only public and private properties that declared in the type)
            PropertyInfo[] ps = type.GetProperties(flags);
            //iterate properties
            foreach (var p in ps)
            {
                //has to have reader and setter
                if (!(p.CanRead && p.CanWrite))
                {
                    throw new InvalidOperationException(
                        $"Cannot read or write property {p.Name} in {type.FullName}, cannot serialize this property");
                }

                sp = p.GetCustomAttribute(typeof(NinoMemberAttribute), false) as NinoMemberAttribute;
                //not fetch all and no attribute => skip this member
                if (sp == null) continue;
                //record property
                members.Add(sp.Index, p.Name);
            }

            //build params
            StringBuilder sb = new StringBuilder();
            var keys = members.Keys.OrderBy(k => k);
            foreach (var key in keys)
            {
                sb.Append(members[key]).Append(",");
            }

            //remove comma at the end
            sb.Remove(sb.Length - 1, 1);

            //replace template members
            template = template.Replace("{members}", sb.ToString());

            //save path
            var output = Path.Combine(ConstMgr.AssetPath, outputPath);
            if (!Directory.Exists(output))
            {
                Directory.CreateDirectory(output);
            }

            //save file path
            output = Path.Combine(output,
                $"{type.Namespace}{(!string.IsNullOrEmpty(type.Namespace) ? "." : "")}{type.GetFriendlyName()}"
                    .Replace(".", "_").Replace(",", "_")
                    .Replace("<", "_").Replace(">", "_") +
                ".cs");
            if (File.Exists(output))
            {
                File.Delete(output);
            }

            //save
            File.WriteAllText(output, template);

            Logger.D("Code Gen", $"saved {output}");
        }

        /// <summary>
        /// 获取类型名字
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private static string GetFriendlyName(this Type type)
        {
            string friendlyName = type.Name;
            if (type.IsGenericType)
            {
                int iBacktick = friendlyName.IndexOf('`');
                if (iBacktick > 0)
                {
                    friendlyName = friendlyName.Remove(iBacktick);
                }

                friendlyName += "<";
                Type[] typeParameters = type.GetGenericArguments();
                for (int i = 0; i < typeParameters.Length; ++i)
                {
                    string typeParamName = GetFriendlyName(typeParameters[i]);
                    friendlyName += (i == 0 ? typeParamName : "," + typeParamName);
                }

                friendlyName += ">";
            }

            return friendlyName;
        }
    }
}