using System;
using System.IO;
using System.Linq;
using System.Text;
using Nino.Shared.Mgr;
using Nino.Shared.Util;
using System.Reflection;
using System.Collections.Generic;

namespace Nino.Serialization
{
    /// <summary>
    /// Nino code generator
    /// </summary>
    public static class CodeGenerator
    {
        /// <summary>
        /// Generate serialization code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="outputPath"></param>
        /// <param name="assemblies"></param>
        public static void GenerateSerializationCodeForAllTypePossible(string outputPath = "Nino/Generated",
            Assembly[] assemblies = null)
        {
            //find all types
            var types = (assemblies ?? AppDomain.CurrentDomain.GetAssemblies()).SelectMany(a => a.GetTypes()).ToList()
                .FindAll(t =>
                {
                    //find NinoSerializeAttribute
                    NinoSerializeAttribute[] ns =
                        (NinoSerializeAttribute[])t.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
                    if (ns.Length == 0) return false;
                    return true;
                }).ToList();
            //iterate
            foreach (var type in types)
            {
                //gen
                GenerateSerializationCode(type, outputPath);
            }
        }

        /// <summary>
        /// Get a valid nino serialize class
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private static bool GetValidNinoClass(Type type)
        {
            //nested
            if (type.IsNested)
            {
                Logger.E("Code Gen", $"Can not generate code for type: {type} due to it is a nested class");
                return false;
            }

            //find NinoSerializeAttribute
            NinoSerializeAttribute[] ns =
                (NinoSerializeAttribute[])type.GetCustomAttributes(typeof(NinoSerializeAttribute), false);
            if (ns.Length == 0) return false;
            if (ns[0].IncludeAll) return false;

            CodeGenIgnoreAttribute[] ci =
                (CodeGenIgnoreAttribute[])type.GetCustomAttributes(typeof(CodeGenIgnoreAttribute), false);
            if (ci.Length != 0) return false;
            return true;
        }

        /// <summary>
        /// Generate serialization code file at Assets/ouputPath
        /// editor only method
        /// </summary>
        /// <param name="type"></param>
        /// <param name="outputPath"></param>
        // ReSharper disable CognitiveComplexity
        public static void GenerateSerializationCode(Type type, string outputPath = "Nino/Generated")
            // ReSharper restore CognitiveComplexity
        {
            //nino class only
            if (!GetValidNinoClass(type)) return;

            //code template
            string template =
                @"/* this is generated by nino */
{namespace}
{start}
    public partial struct {type}
    {
        #region NINO_CODEGEN
        public void NinoWriteMembers(Nino.Serialization.Writer writer)
        {
{members}
        }

        public {type} NinoReadMembers(Nino.Serialization.Reader reader)
        {
{fields}
        }
        #endregion
    }
{end}";
            if (type.IsClass)
            {
                template = template.Replace("struct", "class");
            }

            //replace namespace
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                template = template.Replace("{namespace}", $"namespace {type.Namespace}");
                template = template.Replace("{start}", "{");
                template = template.Replace("{end}", "}");
            }

            //class full name
            var classFullName =
                $"{type.GetFriendlyName()}";
            //replace full name
            template = template.Replace("{type}", classFullName);

            //find members
            TypeModel.TryGetModel(type, out var model);
            //invalid model
            if (model != null)
            {
                if (!model.valid)
                {
                    throw new InvalidOperationException("invalid model");
                }
            }

            //generate model
            if (model == null)
            {
                model = TypeModel.CreateModel(type);
            }

            Dictionary<ushort, MemberInfo> members = model.members;

            #region serialize

            //build params
            StringBuilder sb = new StringBuilder();
            var keys = members.Keys.OrderBy(k => k).ToList();
            foreach (var key in keys)
            {
                var mt = members[key] is FieldInfo fi ? fi.FieldType : ((PropertyInfo)members[key]).PropertyType;
                //enum
                if (mt.IsEnum)
                {
                    sb.Append(
                        $"            writer.CompressAndWriteEnum(typeof({(Enum.GetUnderlyingType(mt).FullName)}), (ulong) this.{members[key].Name});\n");
                }
                //array/list
                else if (mt.IsArray || (mt.IsGenericType && mt.GetGenericTypeDefinition() == ConstMgr.ListDefType))
                {
                    Type elemType = mt.IsGenericType ? mt.GenericTypeArguments[0] : mt.GetElementType();
                    //if nino serialize class => loop call method
                    if (GetValidNinoClass(elemType))
                    {
                        //check null
                        sb.Append($"            if(this.{members[key].Name} != null)\n");
                        sb.Append("            {\n");
                        //write len
                        sb.Append(
                            $"                writer.CompressAndWrite(this.{members[key].Name}.{(mt.IsArray ? "Length" : "Count")});\n");
                        //write item
                        sb.Append($"                foreach (var entry in this.{members[key].Name})\n");
                        sb.Append("                {\n");
                        sb.Append("                     entry.NinoWriteMembers(writer);\n");
                        sb.Append("                }\n");
                        sb.Append("            }\n");
                        //if null then write 0 len
                        sb.Append("            else\n");
                        sb.Append("            {\n");
                        //write len
                        sb.Append("                writer.CompressAndWrite(0);\n");
                        sb.Append("            }\n");
                    }
                    else
                    {
                        sb.Append($"            writer.Write(this.{members[key].Name});\n");
                    }
                }
                //dict
                else if (mt.IsGenericType && mt.GetGenericTypeDefinition() == ConstMgr.DictDefType)
                {
                    var args = mt.GetGenericArguments();
                    Type keyType = args[0];
                    Type valueType = args[1];
                    //if nino serialize class => loop call method
                    var isKeyNino = GetValidNinoClass(keyType);
                    var isValNino = GetValidNinoClass(valueType);
                    if (isKeyNino || isValNino)
                    {
                        //check null
                        sb.Append($"            if(this.{members[key].Name} != null)\n");
                        sb.Append("            {\n");
                        //write len
                        sb.Append($"                writer.CompressAndWrite(this.{members[key].Name}.Count);\n");
                        //write item
                        sb.Append($"                foreach (var entry in this.{members[key].Name})\n");
                        sb.Append("                {\n");
                        //write key
                        sb.Append(isKeyNino
                            ? "                     entry.Key.NinoWriteMembers(writer);\n"
                            : $"                     writer.WriteCommonVal(typeof({BeautifulLongTypeName(keyType)}), entry.Key);\n");
                        //write value
                        sb.Append(isValNino
                            ? "                     entry.Value.NinoWriteMembers(writer);\n"
                            : $"                     writer.WriteCommonVal(typeof({BeautifulLongTypeName(valueType)}), entry.Value);\n");
                        sb.Append("                }\n");
                        sb.Append("            }\n");
                        //if null then write 0 len
                        sb.Append("            else\n");
                        sb.Append("            {\n");
                        //write len
                        sb.Append("                writer.CompressAndWrite(0);\n");
                        sb.Append("            }\n");
                    }
                    else
                    {
                        sb.Append($"            writer.Write(this.{members[key].Name});\n");
                    }
                }
                //not basic type
                else if (!mt.IsPrimitive && mt != ConstMgr.BoolType && mt != ConstMgr.DecimalType &&
                         mt != ConstMgr.StringType)
                {
                    sb.Append(
                        $"            writer.WriteCommonVal(typeof({BeautifulLongTypeName(mt)}), this.{members[key].Name});\n");
                }
                //not enum -> basic type
                else
                {
                    switch (Type.GetTypeCode(mt))
                    {
                        case TypeCode.Int32:
                        case TypeCode.UInt32:
                        case TypeCode.Int64:
                        case TypeCode.UInt64:
                            //compress
                            sb.Append($"            writer.CompressAndWrite(this.{members[key].Name});\n");
                            break;
                        default:
                            //write
                            sb.Append($"            writer.Write(this.{members[key].Name});\n");
                            break;
                    }
                }
            }

            //remove comma at the end
            sb.Remove(sb.Length - 1, 1);

            //replace template members
            template = template.Replace("{members}", sb.ToString());

            #endregion

            #region deserialize

            string GetBasicTypeStatement(Type mt)
            {
                switch (Type.GetTypeCode(mt))
                    {
                        case TypeCode.Int32:
                        case TypeCode.UInt32:
                        case TypeCode.Int64:
                        case TypeCode.UInt64:
                            return $" ({BeautifulLongTypeName(mt)})reader.DecompressAndReadNumber()";
                        case TypeCode.Byte:
                            return "reader.ReadByte()";
                        case TypeCode.SByte:
                            return "reader.ReadSByte()";
                        case TypeCode.Int16:
                            return "reader.ReadInt16()";
                        case TypeCode.UInt16:
                            return "reader.ReadUInt16()";
                        case TypeCode.String:
                            return "reader.ReadString()";
                        case TypeCode.Boolean:
                            return "reader.ReadBool()";
                        case TypeCode.Double:
                            return "reader.ReadDouble()";
                        case TypeCode.Single:
                            return "reader.ReadSingle()";
                        case TypeCode.Decimal:
                            return "reader.ReadDecimal()";
                        case TypeCode.Char:
                            return "reader.ReadChar()";
                        default:
                            return $"({BeautifulLongTypeName(mt)})reader.ReadCommonVal(typeof({BeautifulLongTypeName(mt)}))";
                    }
            }

            sb.Clear();
            int index = 0;
            keys = members.Keys.OrderBy(k => k).ToList();
            foreach (var key in keys)
            {
                var mt = members[key] is FieldInfo fi ? fi.FieldType : ((PropertyInfo)members[key]).PropertyType;
                //enum
                if (mt.IsEnum)
                {
                    var t = BeautifulLongTypeName(Enum.GetUnderlyingType(mt));
                    sb.Append(
                        $"            this.{members[key].Name} = ({BeautifulLongTypeName(mt)})reader.DecompressAndReadEnum(typeof({t}));\n");
                }
                //array/list
                else if (mt.IsArray || (mt.IsGenericType && mt.GetGenericTypeDefinition() == ConstMgr.ListDefType))
                {
                    Type elemType = mt.IsGenericType ? mt.GenericTypeArguments[0] : mt.GetElementType();

                    if (elemType == ConstMgr.ByteType)
                    {
                        sb.Append(
                            $"            this.{members[key].Name} = reader.ReadBytes(reader.ReadLength());\n");
                        continue;
                    }
                    
                    //create field
                    sb.Append(
                        $"            this.{members[key].Name} = new {(mt.IsArray ? BeautifulLongTypeName(elemType) : BeautifulLongTypeName(mt))}{(mt.IsArray ? "[reader.ReadLength()]" : "(reader.ReadLength())")};\n");
                    //write items
                    sb.Append($"            for(int i = 0, cnt = this.{members[key].Name}.{(mt.IsArray ? "Length" : "Capacity")}; i < cnt; i++)\n");
                    sb.Append("            {\n");
                    //if nino serialize class => loop call method
                    string valStr = GetValidNinoClass(elemType)
                        ? $"(new {BeautifulLongTypeName(elemType)}()).NinoReadMembers(reader)"
                        : GetBasicTypeStatement(elemType);
                    
                    if (mt.IsArray)
                    {
                        sb.Append(
                            $"                this.{members[key].Name}[i] = {valStr};\n");
                    }
                    else
                    {
                        sb.Append(
                            $"                this.{members[key].Name}.Add({valStr});\n");
                    }
                    sb.Append("            }\n");
                }
                //dict
                else if (mt.IsGenericType && mt.GetGenericTypeDefinition() == ConstMgr.DictDefType)
                {
                    var args = mt.GetGenericArguments();
                    Type keyType = args[0];
                    Type valueType = args[1];
                    //create field
                    sb.Append($"            var this_{members[key].Name}_len = reader.ReadLength();\n");
                    sb.Append(
                        $"            this.{members[key].Name} = new {BeautifulLongTypeName(mt)}(this_{members[key].Name}_len);\n");
                    //write items
                    sb.Append($"            for(int i = 0; i < this_{members[key].Name}_len; i++)\n");
                    sb.Append("            {\n");

                    //read key
                    string valStr = GetValidNinoClass(keyType)
                        ? $"(new {BeautifulLongTypeName(keyType)}()).NinoReadMembers(reader)"
                        : GetBasicTypeStatement(keyType);
                    sb.Append(
                        $"                this.{members[key].Name}[{valStr}] = ");

                    //read value
                    valStr = GetValidNinoClass(valueType)
                        ? $"(new {BeautifulLongTypeName(valueType)}()).NinoReadMembers(reader)"
                        : GetBasicTypeStatement(valueType);
                    sb.Append($"{valStr};\n");

                    sb.Append("            }\n");
                }
                //not enum -> basic type
                else
                {
                    sb.Append($"            this.{members[key].Name} = {GetBasicTypeStatement(mt)};\n");
                }

                index++;
            }

            sb.Append("            return this;\n");
            //remove comma at the end
            sb.Remove(sb.Length - 1, 1);

            //replace template fiedls
            template = template.Replace("{fields}", sb.ToString());

            #endregion

            //save path
            var output = Path.Combine(ConstMgr.AssetPath, outputPath);
            if (!Directory.Exists(output))
            {
                Directory.CreateDirectory(output);
            }

            //save file path
            output = Path.Combine(output,
                $"{type.Namespace}{(!string.IsNullOrEmpty(type.Namespace) ? "." : "")}{type.GetFriendlyName()}"
                    .Replace(".", "_").Replace(",", "_")
                    .Replace("<", "_").Replace(">", "_") +
                "_Serialize.cs");
            if (File.Exists(output))
            {
                File.Delete(output);
            }

            //save
            File.WriteAllText(output, template);

#if UNITY_2017_1_OR_NEWER
            Logger.D("Code Gen", $"saved {output}");
#else
            Logger.D("Code Gen", $"saved {output}, please move this file to your project");
#endif
        }

        private static string BeautifulLongTypeName(this Type mt)
        {
            return $"{mt.Namespace}{(!string.IsNullOrEmpty(mt.Namespace) ? "." : "")}{mt.GetFriendlyName()}";
        }

        /// <summary>
        /// 获取类型名字
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        private static string GetFriendlyName(this Type type)
        {
            string friendlyName = type.Name;
            if (type.IsGenericType)
            {
                int iBacktick = friendlyName.IndexOf('`');
                if (iBacktick > 0)
                {
                    friendlyName = friendlyName.Remove(iBacktick);
                }

                friendlyName += "<";
                Type[] typeParameters = type.GetGenericArguments();
                for (int i = 0; i < typeParameters.Length; ++i)
                {
                    string typeParamName =
                        $"{typeParameters[i].Namespace}{(!string.IsNullOrEmpty(typeParameters[i].Namespace) ? "." : "")}{GetFriendlyName(typeParameters[i])}";
                    friendlyName += (i == 0 ? typeParamName : "," + typeParamName);
                }

                friendlyName += ">";
            }

            return friendlyName;
        }
    }
}